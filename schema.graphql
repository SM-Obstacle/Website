type CheckpointTime {
	cpNum: Int!
	time: Int!
}

"""
Implement the DateTime<Utc> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime

type Event {
	handle: String!
	cooldown: Int
	admins: [Player!]!
	categories: [EventCategory!]!
	editions: [EventEdition!]!
	lastEdition: EventEdition
	edition(editionId: Int!): EventEdition
}

type EventCategory {
	handle: String!
	name: String!
	bannerImgUrl: String
	hexColor: String
}

type EventEdition {
	id: Int!
	mappack: Mappack
	admins: [Player!]!
	event: Event!
	name: String!
	subtitle: String
	startDate: NaiveDateTime!
	bannerImgUrl: String
	expiresIn: Int
	player(login: String!): EventEditionPlayer!
	map(gameId: String!): EventEditionMap!
	categories: [EventCategory!]!
}

type EventEditionMap {
	edition: EventEdition!
	map: Map!
	linkToOriginal: Boolean!
	originalMap: Map
	records(rankSortBy: SortState, dateSortBy: SortState): [RankedRecord!]!
	recordsConnection(
		"""
		Cursor to fetch records after (for forward pagination)
		"""
		after: String,
		"""
		Cursor to fetch records before (for backward pagination)
		"""
		before: String,
		"""
		Number of records to fetch (default: 50, max: 100)
		"""
		first: Int,
		"""
		Number of records to fetch from the end (for backward pagination)
		"""
		last: Int,		sortField: MapRecordSortableField,		filter: RecordsFilter
	): RankedRecordConnection!
	medalTimes: MedalTimes
}

type EventEditionMapExt {
	map: Map!
	lastRank: Int!
	medalTimes: MedalTimes
}

type EventEditionPlayer {
	player: Player!
	rank: Int!
	rankAvg: Float!
	mapFinished: Int!
	worstRank: Int!
	categorizedRanks: [EventEditionPlayerCategorizedRank!]!
	unfinishedMaps: [EventEditionMapExt!]!
}

type EventEditionPlayerCategorizedRank {
	categoryName: String!
	bannerImgUrl: String
	hexColor: String
	nbMaps: Int!
	ranks: [EventEditionPlayerRank!]!
}

type EventEditionPlayerRank {
	rank: Int!
	time: Int!
	map: EventEditionMapExt!
}

type Map {
	id: ID!
	gameId: String!
	playerId: ID!
	cpsNumber: Int
	player: Player!
	name: String!
	relatedEventEditions: [RelatedEdition!]!
	averageRating: [PlayerRating!]!
	records(rankSortBy: SortState, dateSortBy: SortState): [RankedRecord!]!
	recordsConnection(
		"""
		Cursor to fetch records after (for forward pagination)
		"""
		after: String,
		"""
		Cursor to fetch records before (for backward pagination)
		"""
		before: String,
		"""
		Number of records to fetch (default: 50, max: 100)
		"""
		first: Int,
		"""
		Number of records to fetch from the end (for backward pagination)
		"""
		last: Int,		sortField: MapRecordSortableField,		filter: RecordsFilter
	): RankedRecordConnection!
}

enum MapRecordSortableField {
	DATE
	RANK
}

type Mappack {
	nbMaps: Int!
	mxAuthor: String
	mxCreatedAt: NaiveDateTime
	mxName: String
	leaderboard: [MappackPlayer!]!
	player(login: String!): MappackPlayer!
	nextUpdateIn: Int
}

type MappackMap {
	rank: Int!
	lastRank: Int!
	map: Map!
}

type MappackPlayer {
	rank: Int!
	player: Player!
	ranks: [MappackMap!]!
	rankAvg: Float!
	mapFinished: Int!
	worstRank: Int!
}

type MedalTimes {
	bronzeTime: Int!
	silverTime: Int!
	goldTime: Int!
	championTime: Int!
}

"""
ISO 8601 combined date and time without timezone.

# Examples

* `2015-07-01T08:59:60.123`,
"""
scalar NaiveDateTime

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

type Player {
	id: ID!
	login: String!
	name: String!
	zonePath: String
	role: PlayerRole!
	records(dateSortBy: SortState): [RankedRecord!]!
	recordsConnection(
		"""
		Cursor to fetch records after (for forward pagination)
		"""
		after: String,
		"""
		Cursor to fetch records before (for backward pagination)
		"""
		before: String,
		"""
		Number of records to fetch (default: 50, max: 100)
		"""
		first: Int,
		"""
		Number of records to fetch from the end (for backward pagination)
		"""
		last: Int,		filter: RecordsFilter
	): RankedRecordConnection!
}

type PlayerRating {
	kind: RatingKind!
	rating: Float!
}

enum PlayerRole {
	PLAYER
	MODERATOR
	ADMIN
}

type QueryRoot {
	eventEditionFromMxId(mxId: Int!): EventEdition
	mappack(mappackId: String!): Mappack!
	event(handle: String!): Event!
	events: [Event!]!
	record(recordId: Int!): RankedRecord!
	map(gameId: String!): Map!
	player(login: String!): Player!
	records(dateSortBy: SortState): [RankedRecord!]!
	recordsConnection(
		"""
		Cursor to fetch records after (for forward pagination)
		"""
		after: String,
		"""
		Cursor to fetch records before (for backward pagination)
		"""
		before: String,
		"""
		Number of records to fetch (default: 50, max: 100)
		"""
		first: Int,
		"""
		Number of records to fetch from the end (for backward pagination)
		"""
		last: Int,		filter: RecordsFilter
	): RankedRecordConnection!
}

type RankedRecord {
	id: Int!
	rank: Int!
	map: Map!
	player: Player!
	averageCpsTimes: [CheckpointTime!]!
	cpsTimes: [CheckpointTime!]!
	time: Int!
	respawnCount: Int!
	tryCount: Int!
	recordDate: DateTime!
	flags: Int!
}

type RankedRecordConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [RankedRecordEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [RankedRecord!]!
}

"""
An edge in a connection.
"""
type RankedRecordEdge {
	"""
	The item at the end of the edge
	"""
	node: RankedRecord!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

"""
The various rating kinds available for a map.
"""
enum RatingKind {
	"""
	The rating of the route.
	"""
	ROUTE
	"""
	The rating of the decoration.
	"""
	DECO
	"""
	The rating of the smoothness.
	"""
	SMOOTHNESS
	"""
	The rating of the difficulty.
	"""
	DIFFICULTY
}

"""
Filter options for querying records
"""
input RecordsFilter {
	"""
	Filter by player login
	"""
	playerLogin: String
	"""
	Filter by player name
	"""
	playerName: String
	"""
	Filter by map UID
	"""
	mapUid: String
	"""
	Filter by map name
	"""
	mapName: String
	"""
	Filter records made before this date (ISO 8601 format)
	"""
	beforeDate: NaiveDateTime
	"""
	Filter records made after this date (ISO 8601 format)
	"""
	afterDate: NaiveDateTime
	"""
	Filter records with time greater than this value (in milliseconds)
	"""
	timeGt: Int
	"""
	Filter records with time less than this value (in milliseconds)
	"""
	timeLt: Int
}

type RelatedEdition {
	map: Map!
	"""
	Tells the website to redirect to the event map page instead of the regular map page.
	
	This avoids to have access to the `/map/X_benchmark` page for example, because a Benchmark
	map won't have any record in this context. Thus, it should be redirected to
	`/event/benchmark/2/map/X_benchmark`.
	"""
	redirectToEvent: Boolean!
	edition: EventEdition!
}

enum SortState {
	SORT
	REVERSE
}

"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
"""
Provides a scalar specification URL for specifying the behavior of custom scalar types.
"""
directive @specifiedBy(url: String!) on SCALAR
schema {
	query: QueryRoot
}
